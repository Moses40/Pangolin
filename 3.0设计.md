<!-- TOC -->

- [简介](#简介)
- [概念](#概念)
    - [序列化](#序列化)
    - [账号地址](#账号地址)
    - [区块](#区块)
    - [资产](#资产)
    - [BU币](#BU币)
    - [账号](#账号)
    - [交易 transaction](#交易-transaction)
    - [操作 operation](#操作-operation)
        - [创建账号](#创建账号)
        - [发行资产](#发行资产)
        - [转移资产](#转移资产)
        - [设置metadata](#设置metadata)
        - [设置权重](#设置权重)
        - [设置门限](#设置门限)
- [交易缓存队列](#交易缓存队列)
- [交易费用](#交易费用)
    - [费用选举](#费用选举)
    - [费用计算](#费用计算)
- [交易环境](#交易环境)
- [p2p](#p2p)
- [共识](#共识)
    - [共识节点选举](#共识节点选举)
- [账本](#账本)
- [合约](#合约)
    - [虚拟机介绍](#虚拟机介绍)
        - [C++调用V8引擎简要示例](#C++调用V8引擎简要示例)
        - [虚拟机优化和保护措施](#虚拟机优化和保护措施)
    - [智能合约语法规则介绍](#智能合约语法规则介绍)
    - [智能合约基本模板](#智能合约基本模板)
    - [调试合约](#调试合约)
    - [创建合约](#创建合约)
    - [执行合约](#执行合约)
    - [合约的创建](#合约的创建)
    - [合约的执行](#合约的执行)
        - [触发机制](#触发机制)
        - [执行入口函数](#执行入口函数)
        - [查询函数](#查询函数)
    - [内置实现接口和变量](#内置实现接口和变量)
    - [内置函数](#内置函数)
    - [内置变量](#内置变量)
    - [异常处理](#异常处理)
- [附录](#附录)
    - [Merkel根](#merkel根)
    - [protocol buffer与json的互相转换](#protocol-buffer与json的互相转换)

<!-- /TOC -->

# 简介

# 概念

区块链的鼻祖比特币在设计之初就已经确定了其目的是一种去中心化的数字货币。而布比区块链并不是以数字货币为目的，布比区块链内置的业务场景是数字资产的发行、流通。同时，由于智能合约的存在，用户也可以任意定义自己的业务场景。

## 序列化
很多地方都要用到序列化的功能。比如我们要对一笔交易签名，其实我们只能对字节串签名，这时就需要将交易序列化为字节串；还有我们需要存储交易，也需要序列化为字节流才能存储。我们选择了google的protocol buffer 3协议进行序列化。由此我们的所有数据结构的定义都是用protocol buffer 3 定义的。protocol buffer 3的优点是速度快，占用空间小，有多种语言支持。本文中我们统一用SerializeAsString表示对一个protocol buffer对象的序列化操作。

## 账号地址
在非对称签名体系中，有私钥skey和公钥pkey。它的工作原理是根据算法随机产生一个公私钥对skey和pkey，私钥skey由用户保管，公钥pkey公开,签名时`signature = Sign(skey, message);`。验证时判断`Verify(pkey, signature, message)`为true或false。那么为何不以pkey为用户的唯一标识？因为pkey的长度是不固定的，对于确定的椭圆曲线家族算法来说，pkey一般长度在64字节，而RSA体系中pkey的长度则有几百字节，是不方便用户查看和保存的。为了兼容多种签名算法且固定长度，我们对公钥进行散列运算，再加一些其他的标志位生成**账号地址**。
它是根据公钥计算出来的长度为36字节的字符串。是账号的唯一标识。地址的计算过程：
```
hp = HASH(pkey)
str = 0x01 + 0x56 + type + hp.substr(12)
hash = HASH(HASH(str))
address = BASE58(str + hash.substr(4))
```
- `0x01` 和 `0x56` 经过 base58 计算后分别是字符 `b` 和 `u`，合在一起组成地址的固定前缀`bu`；
- `type`是一个字节，它的值表示不同的签名算法，支持的签名算法有

    ```
    SIGNTYPE_ED25519 = 0x01, //ED25519算法
    SIGNTYPE_CFCASM2 = 0x02,//CFCA版国标SM2
    ```

- `HASH`是散列运算，对于CFCASM2来说，HASH采用SM3国家标准。其余的，都是SHA256标准。
    ```math
    HASH = SM3 //如果签名算法选择CFCASM2
    HASH =  SHA256 //如果签名算法不是CFCASM2
    ```
- `hp`是公钥的散列值。这里的公钥`pkey`是指原始的公钥字节串，对于ED25519来说，pkey是一个长度为32的字节串；对CFCASM2，pkey是长度为65的字节串(未压缩)。
- `hp.substr(12)`指的是公钥的散列值从13个字符起到结尾的子串。
- `hash` 是对多元素拼接的字符串 `str` 的两次HASH运算后的结果。
- `address` 是将 `str` 和 `hash` 从第 5 个字符起到结尾的子串拼接后，再进行 BASE58计算的结果。

## 区块
一个区块由2大部分组成，区块头LedgerHeader和所包含的交易transaction_envs。
```
message LedgerHeader
{
    int64 seq = 1;
    bytes hash = 2;
    bytes previous_hash = 3;
    bytes account_tree_hash = 4;
    int64 close_time = 5;
    bytes consensus_value_hash = 6;
    int64 version = 7;
    int64 tx_count = 8;
    bytes validators_hash = 9;
    bytes fees_hash = 10;
    string reserve = 11;
}

message Ledger
{
   LedgerHeader header = 1;
   repeated TransactionEnv transaction_envs = 2;
}
```

- seq 区块的序号，从1开始递增，每产生1个区块，序号加1，是区块的唯一标识。
- hash 本区块的hash。计算时由Ledger部分序列化之后用散列算法得到,计算之前，先将hash字段设置为空。
```
Ledger.header.hash = "";
Ledger.header.hash = HASH(Ledger.SerializeAsString())
```
- previous_hash 上一个区块hash.对于创世区块没有上一个区块，此值为空。
- account_tree_hash 账号树的hash。
    由当前区块交易执行之后，所有的账号组成默克尔树计算出出来的hash。对于一个账号A，其地址为address，我们定义
    ```
    K = address
    V = Account.SerializeAsString()
    ```
    所有的账号以(K,V)形式组成集合ACCOUNTS
    ```
    account_tree_hash = MerkelRootHash(ACCOUNTS)
    ```
    参见[Merkel根](#merkel根)
- close_time 区块形成时间。创世区块中该值为0，其余区块中该值由共识算法得到。
- consensus_value_hash 由共识算法提供的一个hash值。创世区块中此值为空。
- version 区块的版本号。若区块生成的设计上有变更，区块版本号可以作为识别的依据，在不同的区块中采取不同的规则。
- tx_count 到目前为止，系统中所有的交易数量。
- validators_hash 验证节点列表hash，和共识相关。由于支持动态增加或删除验证节点，它的意义是确定本区块生成时，验证节点列表。假设当前验证节点集合为`A={x|x是验证节点的地址之一}`，那么`validators_hash = HASH(A)`
- fees_hash 交易费用hash。
    对交易的gas价格和账户最低预留费用序列化之后的hash。
- reserve 保留字段

## 资产
资产是由账号发行出来的数字凭证。
```
message Asset
{
    AssetKey key = 1;
    int64 amount = 2;
}
message AssetKey
{
    string issuer = 1;
    string code = 2;
    int32 type = 3;
}

```
资产有两个关键元素，资产标识key和数量amount。其中key又由发行方issuer、代码code发行方式type组成。注意，只有当两种资产的issuer和code都相同时，我们才认为它们是同一类资产，它们的数量才可以相加。资产是不会凭空消失和产生的，当一个账号发行资产时，资产会被创建，代码和数量都由本次发行的动作指定，发行方就是该账号。资产转移时，转出方相应的资产数量会减少，接收方该资产数量会增加，减少的量等于增加的量。转移过程中，发行方和代码属性不会变化。

## BU币
BU币是BU链内置的原生token，用于支付网络交易费用和区块链网络的运营维护。BU链启动时，在创世账户被创建时内置生成10亿BU币。除了初始化内置的部分外，每次有新的区块生成时，也会产生一定数额的BU币，用来奖励参与区块打包的共识节点。每次区块产生奖励的BU币和该区块内所有为交易支付的费用，将被均匀分给所有此次参与区块打包的共识节点，取模的余额将随机奖励给某个参与共识的节点。区块奖励的总额为5亿。初始阶段，每个区块奖励8个BU币，以后，每五年每个区块奖励的BU币个数减半，360年后5亿BU币将全部奖励完毕。

## 账号

账号是布比区块链的主体，是对现实社会中法人或自然人一种的映射。账号是这样定义的：
```text
message Account
{
    string address = 1;
    int64  nonce = 2;
    AccountPrivilege priv = 3;
    bytes metadatas_hash = 4;
    bytes assets_hash = 5;
    Contract contract = 6;
    int64 balance = 7;
}
```

- address 账号地址，见[账号地址](#账号地址)
- nonce 序号
一个从0开始的数字，代表该账号发起过的交易数量。它的另一个作用是防止对签名的重放攻击（注意不是双花）。每当该账号执行一笔交易后，该账号的序号就会加1，无论该交易成功还是失败。当你用一个账号发起交易时，要在该交易中指定一个nonce值，交易中的这个nonce值必须比当前账号的nonce大1。当一个账号被新建时，它的nonce为0。

- priv 该账号的权限配置
正常情况下，一个账号发起交易需要其私钥的签名。我们允许账号将其签名的权力量化并分配给其他的私钥。系统在判断签名的合法性时，不仅会判断其本身的签名，还会判断其分配给其他私钥的签名。将合法的签名权重相加，最后得出权重值不小于设定的权重，则认为交易签名通过。
    ```
    message AccountPrivilege 
    {
        int64 master_weight = 1;
        repeated Signer signers = 2;
        AccountThreshold thresholds = 3;
    }

    message Signer
    {
        enum Limit
        {
            SIGNER_NONE = 0;
            SIGNER = 100;
        };

        string address = 1;
        int64 weight = 2;
    }

    message AccountThreshold
    {
        int64 tx_threshold = 1;
        repeated OperationTypeThreshold type_thresholds = 2;
    }

    message OperationTypeThreshold
    {
        Operation.Type type = 1;
        int64 threshold = 2;
    }

    ```

    - AccountPrivilege.master_weight 本私钥的权重
    - AccountPrivilege.signers 各个地址的权重
    - AccountThreshold.tx_threshold 发起交易的门限，权重超过该门限才可以交易
    - OperationTypeThreshold 各种操作的门限，权重超过该门限才可以执行该类操作。其中`type`是操作码，`threshold`是操作门限。默认情况下，AccountThreshold.type_thresholds是空的，即所有的操作所需的权重都和`AccountThreshold.tx_threshold`一样。
    
- 权重的传递 通过上一节，我们知道账户的权限是由两个部分组成的：权重和门限。交易通过附带的签名被赋予权重有两种情况：该账号地址对应的私钥签名，则交易被赋予master_weight权重；如果交易被 签名者列表的某个地址 signerA 对应的私钥签名，则交易被赋予该地址对应的的weightA权重；更高级点，如果该账号地址的signerB 同时也存在区块链上,并且也有signerBA，该交易由signerBA对应的私钥签名，则交易可能被赋予singerB的权重值。该模式类比集团和子公司，集团董事会成员的投票可以直接影响到子公司的决策。

- 交易有效性的代码判断如下图。递归最深层次为5，也就是说：A->B->C->D->E, A最多递归到E，不再往下查询。同时 A->B->A 这条路径是不允许的。

    ```
    SignerHasPriv(a Account, type OperationType, tx Transaction, statck_deep){
       
        
        if stack_deep >= 5 or AccountNotFound(a.signerA.address) 
        then return FindSignature(a.address);
        else
             define weight;
             define threshold = tx.GetThreshold(type);
             if FindSignature(a.address) then weight += a.master_weight;
             
             for signer each a.signers
             {
                 if FindPath(signer.address)
                 then return false;
                 
                 if SignerHasPriv(signer.address, type, tx, stack_deep+1)
                 then weight += signer.weight
                 
                 if weight >= threshold
                 then return true
             }
             
             return false;
    }
    
    ```


- metadatas_hash 
每个账号都有自己的一个小型的“版本化的键值对数据库”，用来存储用户自定义的内容。每一条数据我们都称为一个metadata，它有3个元素键key、值value和版本号version。每当修改这条数据，它的版本号就会自动加1。
    ```
    message KeyPair
    {
        string key = 1;
        string value = 2;
        int64 version = 3;
    }
    ```
    对于一个账号的每一条metadata

    ```
    K = KeyPair.key
    V = KeyPair.SerializeAsString()
    ```
    我们将(K,V)作为一个元素，所有的这样的(K,V)元素组成的集合记为metadatas，那么
    ```
    metadatas_hash = MerkelRootHash(metadatas)
    ```
    其中MerkelRootHash是对这个集合进行默克尔树进行HASH运算，参见[Merkel根](#merkel根)。
- assets_hash
每个账号名下可以拥有很多种资产，资产的定义

该账号的所有资产组成的Merkel树计算出来的根hash。我们将所有的资产组成键值对的结构,对于账号拥有的每个资产。

```
K = asset.property.SerializeAsString()
V = asset.SerializeAsString()
```
将这个账号所有的资产生成的(K,V)组成集合记为ASET

```
assets_hash = Merkel(ASET)
```
参见[Merkel根](#merkel根)

- contract
智能合约，如果该成员不为空，那么此账户为智能合约账户。关于智能合约，请参见[合约](#合约)。

- balance
账户的BU币余额。当账户打包并请求执行一笔交易的时候，支付的交易费用将从balance中扣除。如果支付的费用超过交易执行实际需要的费用，多余的部分将返回账户balance。注意：账户至少要保留0.1BU的预留费用，如果扣除交易费后balance低于该值，则拒绝执行该交易请求。
参见[交易费](#交易费)

## 交易 transaction

交易广义的定义，它是一个对账号进行一系列操作的组合。

```
message TransactionEnv 
{
    Transaction transaction = 1;
    repeated Signature signatures = 2;
    Trigger trigger = 3;
}
```

- transaction 交易的主体，指定了这笔交易要做什么
- signatures 交易的签名
- trigger 这笔交易是如何发生的，由账号发起还是由合约发起

交易的主体定义
```
message Transaction 
{
    enum Limit
    {
        UNKNOWN = 0;
        OPERATIONS = 1000;
    };
	
    string source_address = 1;
    int64 nonce = 2;
    int64 fee_limit = 3;
    int64 gas_price = 4;
    int64 ceil_ledger_seq = 5;
    bytes metadata = 6;
    repeated Operation operations = 7;
}

message Signature 
{
	string public_key = 1;
	bytes sign_data = 2;
}

```
- source_address 这笔交易的发起账号，必须是系统中已经存在的一个账号
- nonce 发起账号的当前nonce+1
- fee_limit 交易提供的费用（上限）
- gas_price gas的价格，gas可被理解为交易消耗的能量，每字节消耗一个gas，交易消耗的gas量和gas价格的乘积就是实际费用
- ceil_ledger_seq 交易的区块高度限制。如果大于0，则交易只有在该区块高度之前才有效
- metadata 本交易用户自定义的备注。长度范围 [0, 262144]
- operations 交易的有效负载，指定了这笔交易做什么

系统在共识过程中，会初步判断交易的合法性，参数合法性和签名的合法性。只有参数和签名合法的交易才可能通过共识

1. transaction各项参数符合上面的要求
2. TransactionEnv序列化之后的长度在(0,4194304]
3. `source_address`指定的发起账号存在，且发起账号的nonce等于交易nonce + 1
4. 根据交易发起账号的priv字段，得到其thresholds.tx_threshold
对TransactionEnv中所有验证通过的签名，取address组成集合记为……

## 操作 operation

操作是交易中附带的具体动作，改变账号的原子单位。一个交易，必定是包含了1个或多个操作。
```
message Operation 
{
    enum Type 
    {
       UNKNOWN = 0;
       CREATE_ACCOUNT = 1;
       ISSUE_ASSET = 2;
       PAY_ASSET = 3;
       SET_METADATA = 4;
       SET_SIGNER_WEIGHT = 5;
       SET_THRESHOLD = 6;
       PAY_COIN = 7;
       LOG = 8;	
    };
    Type type = 1;
    string source_address = 2;
    bytes metadata = 3;
    
    OperationCreateAccount create_account = 4;
    OperationIssueAsset issue_asset = 5;
    OperationPayment pay_asset = 6;
    OperationSetMetadata set_metadata = 7;
    OperationSetSignerWeight set_signer_weight = 8;
    OperationSetThreshold set_threshold = 9;
    OperationPayCoin pay_coin = 10;
    OperationLog log = 11;
}
```
操作有8种类型，共有属性是`type,source_address,metadata,expr_condition`。
- type 操作的类型，取值范围[1,8],对应的参数会起作用。如type值为3，那么`pay_asset`这个字段中的值会生效，其余的字段无视。
- source_address 操作源账号地址，即本操作针对哪个账号生效。
- metadata 用户自定义的一段数据，可作为备注用。长度范围[0, 1048576]。

### 创建账号
账号为交易的主体，所有的交易必须通过账号发起执行。因此，在执行其他操作之前必须首先`创建账号`。`创建账号`操作由其他已存在的账号申请执行。第一个账号是在BU链启动时内置生成的，也被成为创世账号。
```
message OperationCreateAccount
{
    string dest_address = 1;
    Contract contract = 2;
    AccountPrivilege priv = 3;
    repeated KeyPair metadatas = 4;	
    int64 init_balance = 5;
    string init_input = 6; 
}

message Contract
{
    enum ContractType
    {
        JAVASCRIPT = 0;
    }
    ContractType type = 1;
    string payload = 2;
}
```
- dest_address 要创建的账号地址
- contract 是否是合约账号，非合约账号可以不填写。
    - type 合约所用语言，目前暂时只支持JavaScript
    - payload 合约代码
- priv 该账号的权限配置，参见[权限配置](#权限配置)
- metadatas 创建账号时同时设置该账号的metadata，可以不填。
- init_balance 创建账号时赋予的初始BU币数额，从创建该账号的源账户的balance内扣取。
- init_input 合约的初始化参数，可根据 contract 选填。

在区块链上创建一个新的账号。成功条件：
- 各项参数合法
- 要创建的账号在区块链中不存在，即不能创建已有的账号
- 若创建时指定了合约代码，合约语法必须正确

### 发行资产
任意一个账户都可以通过执行`发行资产`操作创建属于自己的[资产](#资产)。
```
message OperationIssueAsset
{
    string code = 1;
    int64 amount = 2;
}
```
- code 资产代码，和资产发行者一起构成资产唯一标识
- amount 发行数量

发行一笔资产。成功条件：
- 各项参数合法
- 发行资产后，本账户的该资产余额不超int64最大值

### 转移资产
通过`转移资产`操作，可以将源账号下的制定资产转移给目的地址。
```
message OperationPayAsset
{
    string dest_address = 1;
    Asset asset = 2;
    string input = 3;
}
```
- dest_address 资产接收方地址
- asset 转移的资产项, 参见[资产](#资产)
- input 合约参数，选填，若资产接收方为合约账户, 则input为传给该合约的参数
将资产转移给其他账号，成功条件
- 各项参数合法
- 本账户拥有该类型资产，且数量足够
- 接收方账户存在
- 接收方账户收到该类型资产后，其数额不超过int64最大值

### 转移BU币
```
message OperationPayCoin
{
    string dest_address = 1;
    int64 amount = 2;
    string input = 3;
}
```
- dest_address 收款账户地址
- amount 转账数额
- input 合约参数，选填，若收款账户为合约账户, 则input为传给该合约的参数
将BU币转给其他账户，成功条件
- 各项参数合法
- 本账户BU数量足够
- 接收方账户存在
- 接收方账户收到BU币后，其数额不超过int64最大值

### 设置metadata
metadata是一个带版本的键值对数据库。它的每一个键值对，都有一个版本号，每当修改了这条数据，版本号就会自动加1。
```
message OperationSetMetadata
{
    string key = 1;  
    string value = 2;
    int64 version = 3; 
}
```
- key 数据库的键，长度范围(0,1024]
- value 要设置的值,长度范围[0, 262144]
- version 版本号。每条数据都有其版本号，从初始的0开始，每修改一次会递增1。这里的version可以不填写，如果填写了大于0的数，要表达的意思是在此版本的基础上修改。这可以达到并发控制的目的。比如一条数据当前版本是3，用户想要在版本3的基础上设置，他就可以填写OperationSetMetadata.version 为3。当交易执行时，若这条数据的版本不是3（有人改过）,那么本次修改失败。适合多用户共同操作一个账号，需要并发控制的情况。
成功条件
- 各项参数合法
- 源账号存在
- 版本号为0或版本号等于该数据的当前版本号。

### 设置权重
设置账户拥有者和签名者在源账号下的权重。
```
message OperationSetSignerWeight
{
    int64 master_weight = 1;
    repeated Signer signers = 2;
}
```
- master_weight 账户拥有者权重, 若值为-1表示不设置
- signers 签名者列表，如果某个签名者的weight值为0，表示删除此签名者，关于Signer，请参见[账号](#账号)下的priv设置
成功条件
- 各项参数合法
- 当前操作的签名权重超过`设置权重`操作的门限
- 源账号存在

### 设置门限
设置源账号下各项操作的门限，如果交易中某项操作的权重没有达到该操作的门限值，该操作将被拒绝。
```
message OperationSetThreshold
{
    int64 tx_threshold = 1;
    repeated OperationTypeThreshold type_thresholds = 4;
}
```

- tx_threshold 交易的门限
- type_thresholds 各类操作的具体门限，如果值为0表示删除这个类型的门限
成功条件
- 各项参数合法
- 当前操作的签名权重超过`设置门限`操作的门限
- 源账号存在

# 交易缓存队列
区块链网络内任意一个节点收到一笔交易请求后，首先会对交易进行合法性检查。比如交易源账号的nonce值是否合法；交易请求是否超过字节大小限制；交易相关地址是否合法；交易内操作的权限是否达到门限值；提供的交易费用是否足够或扣除交易费用后源账号的balance是否低于最小预留费用（参见[交易费用](#交易费用)）等等。如果检查合法，则将此交易请求广播给其他节点，并将此请求加入到交易缓存队列中。

## 队列缓存大小的上限
交易缓存队列的缓存有两个限制，第一是整个缓存队列可容纳交易个数的上限，第二是每个源账号在交易缓存队列中可缓存的交易个上限，超过任何一项上限的交易都会被直接丢弃。这两个限制可通过配置文件配置，如果没有配置，则采用默认值，默认队列大小为10240，单账号缓存大小为64。
伪代码示例：
```
sourceAddress = transaction.getSourceAddress()
if(transactionQueue.lenth() > 10240 || transactionQueue.getTransactionAmountOfAccount(sourceAddress) > 64)
{
    return "transaction cache queue already full."
}
else
{
    transactionQueue.insert(transaction)
}

```

## 交易缓存超时处理
交易在缓存队列的存续时间也有限制，系统内维护有一个交易时间和交易在缓存队列中位置的索引。系统依靠定时器做超时检查，每隔一段时间就遍历索引，将超过60s仍留在缓存队列中而未被打包的交易从`时间索引`和队列中同时删除。
伪代码示例：
```
function OnTimer()
{
    for(element in timeIndexTable)
    {
        if(element.requestTime - now() > 60s)
        {
            transactionQueue.Delete(element.transactionPointer)
            timeIndexTable.Delete(element)
        }
    }
}
```

## 交易在队列中的排序
交易缓存队列根据两重条件排序，分别为交易源账号的nonce偏移值和提供的交易费用。源账号nonce偏移值相同但费用不同的交易，费用高的优先。
伪代码示例：
```
function orderBy(transactionL, transactionR)
{
    nonceOffset = transactionL.getNonce() - transactionR.getNonce()
    fee = transactionL.GetGasPrice() - transactionR.GetGasPrice()
    return nonceOffset < 0 || (nonceOffset == 0 && fee > 0);
}

transactionQueue.sort(orderBy())

```
场景示例：
假如现在有两个账号A和B，他们在系统中当前的nonce值分别是2和5，现在账号A打包了两笔交易`A(nonce3, fee7)、A(nonce4, fee7)`，B也打包了两笔交易`B(nonce6, fee9)、B(nonce8, fee8)`，那么交易`A(nonce3, fee7)`和`B(nonce6, fee9)`相对系统内当前的nonce值偏移都是1，但是`B(nonc6, fee9)`的交易费更高，所以`B(nonce6, fee9)`排在前面，而`B(nonce8, fee8)`的费用虽然比`A(nonce4, fee7)`高，但是相对系统内nonce值的偏移更小，所以`A(nonce4, fee7)`排在`B(nonce8, fee8)`前面。所以，这四笔交易在队列中的排序应该是：

```
B(nonce6, fee9)、 A(nonce3, fee7)、 A(nonce4, fee7)、 B(nonce8, fee8)
```

## 交易在队列中的插入和删除
交易缓存队列维护有三套索引，除了前面提到的`时间索引`，还有`地址+nonce索引`和`交易hash索引`，索引的值都是交易在缓存队列中的位置。这样交易缓存队列插入或删除交易时，可以根据需要从三种索引中找到指定交易的位置。无论插入还是删除，都要同时更新这三种索引和消息缓存队列。如果在插入某个交易时发现队列中已存在相同源账号和nonce的交易，则首先删除队列内的该交易，然后再有序插入新的交易。上文[队列缓存大小的上限](#队列缓存大小的上限)提到缓存队列有大小限制，如果插入时超过队列上限，将根据[交易在队列中的排序](#交易在队列中的排序)规则挤出队列尾部的交易。
伪代码示例：
```
function deleteTransactioFromQueue(addressAndNonce)
{
    transactionPointer = ddressNonceIndexTable.find(addressAndNonce)
    if(transactionPointer != null)
    {
        transactionQueue.Delete(transactionPointer)
        timeIndexTable.Delete(transactionPointer)
        addressNonceIndexTable.Delete(transactionPointer)
        hashIndexTable.Delete(transactionPointer)
    }
}

function insertTransactionToQueue(transaction)
{
    addressAndNonce = transaction.getSourceAddress() +  transaction.getNonce()
    deleteTransactioFromQueue(addressAndNonce)
    transactionQueue.sortedInsert(transaction)
    transactionPointer = transactionQueue.find(transaction)
    timeIndexTable[now()] = transactionPointer
    addressNonceIndexTable[addressAndNonce] = transactionPointer
    hashIndexTable[transaction.getSelfHash()] = transactionPointer
}
```

## 交易的打包
系统依靠定时器每10s发起一轮共识来打包用于生成新区块的交易。打包时，从交易缓存队列的头部开始有序抓取不超过4M字节的交易。如果遇到交易源账号序号断号的情况，将会从断号位置跳过该源账号请求的所有的交易，并标记该源账号断号位置，在断号补齐之前后续的区块也不会打包该源账号的交易，直到补齐断号，或者在交易缓存队列缓存超时被删除。
伪代码示例
```
arrayObject transactionPackage
arrayObject breakAccount
for(transaction in transactionQueue)
{
    if(breakAccount.find(transaction.getSourceAddress()) == true)
    {
        continue
    }
    else
    {
        if(transactionPackage.find(transaction.getSourceAddress()) == true)
        {
            lastSequenceTransation = transactionPackage.getTransactionReversed(transaction.getSourceAddress())
            if(lastSequenceTransation.getNonce() + 1 < transaction.getNonce())
            {
                breakAccount.insert(transaction.getSourceAddress())
                countinue
            }
        }
    }

    if(transactionPackage.serialize().size() > 16M)
    {
        break
    }

    transactionPackage.insert(transaction)
}

```

场景示例：
假如缓存队列中存在以下9笔交易

```
B(nonce1, fee9)、 A(nonce1, fee7)、 C(nonce1, fee6)、 B(nonce2, fee8)、 C(nonce2, fee5)、 A(nonce3, fee9)、 C(nonce3, fee8)、 B(nonce3, fee4)、 A(nonce4, fee7)
```

那么在打包交易的时候，在抓取到A(nonce3, fee9)的时候，发现交易源账号A的交易存在断号，没有nonce为2的交易，那么就会跳过交易A(nonce3, fee9)和A(nonce4, fee7)，打包其他7笔交易。并标记A(nonce3, fee9)的位置，让后续的区块也不打包A请求的交易，直到在A的剩余交易缓存超时之前有nonce为2的A账户的交易请求插入进来。

# p2p

# 共识

## 共识节点选举
为了保证整个区块链网络的稳定性和成长性，BU链提供了验证节点选举功能。这样，可以将发现的作恶的验证节点剔除共识节点群体，也可以选举性能更高的节点加入验证节点。

在区块链启动之初，创建一个共识节点选举合约账户，该账户是网络全局唯一的。

如果某个普通节点要申请成为验证节点，可以向选举账户转移一笔BU币作为质押股权，数额不得低于5万BU币。转移后，需要当前验证节点对其投票认证。投票通过率为70%，投票数 >= 四舍五入( 验证节点总数 * 投票通过率 ) 则投票通过，例如，假设总共有 4 个验证节点，那么 4 * 0.7 = 2.8，四舍五入后为 3，那么投票数必须 >= 3 才能通过, 如果总共有 6 个验证节点，那么 6 * 0.7 = 4.2，四舍五入后为 4，投票数必须 >= 4 才能通过。投票通过后，申请节点成为验证节点候选人，并触发候选人列表（包括验证节点）排序，在候选人列表前100位的节点将成为验证节点，期间可能有原有验证节点落选和新节点成为验证节点。

如果某个验证节点怀疑另一个验证节点是恶意节点，可以提案废止该节点。其他验证节点可以对该嫌疑节点投票，如果投票通过（投票率同申请节点），则废除该节点的验证者资格，并扣除10%的质押股权均分给其他验证节点。

伪代码示例：
```
function main(input)
{
    if(input.type == TypeApplyAsValidator)
    {
        array ballot
        saveProposal(key = "apply" + sender, value = ballot)
    }
    else if(input.type === TypeVoteApply)
    {
        ballot = getProposal(key = "apply" + input.applicant)
        ballot.push(sender)
        
        if(ballot.size() < (validatorSize * 0.7) + 0.5)
        {
            saveProposal(key = "apply" + input.applicant, value = ballot)
        }
        else
        {
            candidates = getCandidates("candidates")
            candidates.push(input.applicant)
            candidates.sort()
            validators = candidates.top(100)
            //调用区块链提供给智能合约的接口将选举出的验证节点更新为到区块链
            setValidatorsToBlockChain(validators)
        }
    }
    else if(input.type == TypeAbolishValidator)
    {
        array ballot
        saveProposal(key = "abolish" + input.evil, value = ballot)
    }
    else if(input.type == TypeVoteAbolish)
    {
        ballot = getProposal(key = "abolish" + input.evil)
        ballot.push(sender)
        if(ballot.size() < (validatorSize * 0.7) + 0.5)
        {
            saveProposal(key = "abolish" + input.evil, value = ballot)
        }
        else
        {
            candidates = getCandidates("candidates")
            candidates.pop(input.evil)

            //此处省略扣除罚金和均分的伪代码
            candidates.sort()
            validators = candidates.top(100)
            setValidatorsToBlockChain(validators)
        }
    }
} 
```

无论是申请成为验证节点，还是废止恶意节点，或者是对二者的投票，都需要向选举账户转移一笔BU币，只不过废止操作和投票操作转账额可以为0。如伪代码所示，转账时，需要提供对应操作的input作为参数。

# 交易环境
同一笔交易中的所有操作，要么同时成功，要么同时失败，这被称为交易的原子性或者事务性。BU链提供了`交易环境`来保证交易的原子性。每一笔交易执行过程中，会将所有操作的数据写到`交易环境`的执行缓存中。如果在执行过程，有一笔操作失败了，那么该笔交易内剩余的操作将不再执行，并将整个缓存丢弃，以回滚到整笔交易执行之前的数据状态。如果此交易内的所有操作都执行成功，那么就将整个缓存更新到数据库中。通过以上机制，可以保证，交易内的所有操作，要么全部成功，要么全部失败。

伪代码示例：
```
class Environment
{
    memberObject m_dataCache
    memberObject m_realData
    memberFunction set(key, value)
    {
        m_dataCache[key] = value
    }

    memberFunction get(key)
    {
        return m_dataCache[key]
    }

    memberFunction commit()
    {
        m_realData.update(m_dataCache)
    }
}
```

# 交易费用
用户发送交易请求必须支付相应的交易费用，以填补区块链网络内计算机节点设备的折旧、电力、运维等成本。在BU链中，区块链费用可以在交易前评估，且评估不收取任何费用，以方便用户根据自身情况合理提供交易费用。此外，费用的标准也可以在区块链运行过程中根据实际需要选举修改。

## 费用基本概念
交易费用有两个基本概念：gas_price（即gas价格）和fee_limit（即费用上限）两部分，用户在交易请求中必须提供gas_price和fee_limit，否则无法计算和扣除交易费用。
在BU链中，每个BU币为1亿MO，gas_price默认为1000MO，即十万分之一BU，如果用户想让自己提交的交易请求有更高的处理优先级，可以提供比默认值更高的gas_price和fee_limit，参见[交易在队列中的排序](#交易在队列中的排序)，但gas_price不能低于默认值。交易中每个字节消耗1个gas，如果交易中有创建合约或发行资产操作，需要额外支付gas。每个创建合约操作需要100万gas，每个发行资产操作需要500万gas。

```
1BU = 100000000MO
gas_price default 1000MO
1byte cost 1gas
issueAsset cost 5000000gas
createContract cost 1000000gas
```

## 交易前基本费用计算和检查
在交易提交时，即在交易被加入交易缓存队列之前，收到交易请求的节点就会对交易的合法性做检查，其中就包括基本的费用检查（不包括合约调用触发的交易产生的费用）。检查时，首先获取交易源账户的balance（即账户余额）和base_reserve（即最低预留费用），用balance减去fee_limit的差和base_reserve做比较，如果低于base_reserve则交易费用不足拒绝交易请求。如果不低于，则用交易消耗的gas数，即交易字节数，乘以gas_price，再加上交易中创建合约或者发行资产产生的额外费用（如果有的话）的总数，和用户提供的fee_limit比较，如果大于fee_limit则交易费用不足，拒绝请求，如果小于，则基本费用检查合法。
伪代码示例:

```
function calculateFee(transaction)
{
    account = getAccount(transaction.getSourceAddress())
    if( account.getBalance() - fee_limit < account.getBaseReserve() )
    {
        return "base reserve fee not enough."
    }

    allBytesFee = gas_price * transaction.byteSize()

    extraFee = 0;
    for(operation in transaction)
    {
        if(operation.type() == TypeCreateContract)
        {
           extraFee += 0.01BU
        }
        else if(operation.type() == TypeIssueAsset)
        {
            extraFee += 0.05BU
        }
    }

    actualFee = allBytesFee + extraFee
    if(actualFee > fee_limit)
    {
        return "fee not enough."
    }

    return actualFee
}

```
## 费用评估
基本费用检查通过并不能保证支付的交易费用一定足够，因为基本费用检查并不包括合约触发交易产生的费用。所以，为了保证支付的交易费用足够，用户可以先调用费用评估接口评估费用。BU链提供了名字为TestTransaction的http接口供用户评估交易费用。
费用评估会在一个完全仿真的环境中实际执行交易，根据交易的实际执行计算真实的交易费用。
伪代码示例(承接[交易前基本费用计算和检查](#交易前基本费用计算和检查)的代码示例)：
```
function ExecuteTransaction(transaction)
{
    realFee = calculateFee(transaction)
    for(operation in transaction)
    {
        //执行交易操作
        //.....
        //.....

        if(operation.type == TypePayAsset || operation.type == TypePayCoin)
        {
            destAccount = getAccount(operation.destAddress())
            if(destAccount.hasContract() == true)
            {
                contractTransaction = destAccount.Contranct().triggeredTransaction()
                realFee += ExecuteTransaction(contractTransaction)
            }
        }
    }

    return realFee
}

```

## 费用计算
费用计算和[费用评估](#费用评估)的逻辑一致，只不过费用评估是在完全仿真环境中执行，而费用计算是实际交易中计算的，此处不再赘述。

## 费用选举
在区块链网络实际运行过程中，可能需要根据实际情况调节交易费用。比如，在共识节点运维成本固定的情况下，全网交易量不断增长，就摊薄了每个交易的成本，这时候就需要有一种全网共识机制来调低交易费。所以，BU链需要提供费用选举机制。
在区块链启动之初，创建一个费用选举合约账户。账户的代码逻辑如下：
```
function main(input)
{
    if(validatorList.find(sender) == false)
    {
        return "sender is not validator, can't voting."
    }

    if(input.type == TypeProposal)
    {
        array ballot.push(sender)
        saveProposal(key = input.new_gas_price, value = ballot)
    }
    else if(input.type === TypeVote)
    {
        ballot = getProposal(key = input.new_gas_price)
        ballot.push(sender)
        
        if(ballot.size() < (validatorSize * 0.7) + 0.5)
        {
            saveProposal(key = input.new_gas_price, value = ballot)
        }
        else
        {
            //智能合约调用区块链提供的接口设置新费用
            setToBlockChain(input.new_gas_price)
            deleteProposal(key = input.new_gas_price)
        }
    }
} 
```

如果某个验证节点认为当前费用需要更新，那么就向费用选举账户转移一些BU币，数额可以为0，并提供操作类型`提案新费用`和新费用值作为合约的参数。费用选举账户收到转账后，触发费用选举合约。合约检查sender（即支付方）是否为验证节点，如果不是则拒绝执行，如果是，则将新的费用生成提案保存到合约账户的metadata中（参见[设置metadata](#设置metadata)），供其他验证节点投票。
其他验证节点如果投支持票，则向费用选举账户转移一些BU币，数额同样可以为0，提供操作类型`投票`和新费用值（作为key获取提案用）。选举合约以新费用值为key，获取费用提案，并将投票节点的地址写入投票列表。然后检查投票个数是否超过了提案通过率（同[共识节点选举](#共识节点选举))，如果没有超过，将包括投票列表在内的提案重新保存。如果超过了，则调用区块链提供的合约接口，将交易费用设置为提案的新费用，并删除提案，完成投票。
另外，每个提案有投票时间限制，默认是15天，15天内如果投票额不满足投票通过率，则删除提案。

# 合约

合约是账号的属性，定义在 `Account` 的 `contract` 字段上。
```
message Contract
{
    enum ContractType{
        JAVASCRIPT = 0;
    }
    ContractType type = 1;
    string payload = 2;
}

```
- `type`是合约的语言，默认是 `JavaScript`。
- `payload`是代码内容。

## 虚拟机介绍
Bumo 使用 Google V8 engine 作为虚拟机，V8 是一个由 Google 开发的开源 `JavaScript` 引擎，能将 js 代码直接编译成机器码在物理机上执行，以此提升性能。

### c++ 调用 V8 引擎简要示例
在 C++ 里使用 Google V8 engine 执行一段 JS 代码 `function hello() { print('hello, world'); print('ledgerNum: ' + ledgerNum); }` 并调用 `hello` 方法如下：

```     
//声明并定义内置函数 
static void myPrint(v8::Value& args) 
{ 
    v8::String::Utf8Value str1(args[0]);
    printf("%s\n", ToCString(str1);); 
}
```

```
//创建孤立的沙箱环境
v8::Isolate::CreateParams create_params;
v8::Isolate* isolate = v8::Isolate::New(create_params);;
v8::Isolate::Scope isolate_scope(isolate);
v8::HandleScope handle_scope(isolate);
v8::TryCatch try_catch(isolate);

//设置内置函数
v8::Local<v8::ObjectTemplate> global = v8::ObjectTemplate::New(isolate);
global->Set(
    v8::String::NewFromUtf8(isolate, "print", v8::NewStringType::kNormal).ToLocalChecked(),
    v8::FunctionTemplate::New(isolate, myPrint));

//设置内置变量
v8::Local<v8::Context> context = v8::Context::New(isolate, NULL, global);
context->Global()->Set(context,
    v8::String::NewFromUtf8(isolate, "123456", v8::NewStringType::kNormal).ToLocalChecked(),
    v8::String::NewFromUtf8(isolate, "ledgerNum", v8::NewStringType::kNormal).ToLocalChecked());

//创建 js 文本环境
v8::Local<v8::Context> context = v8::Context::New(isolate, NULL, global);

//编译 js 代码
v8::Local<v8::Script> compiled_script;
v8::Local<v8::String> v8src = v8::String::NewFromUtf8(isolate, "function hello() { print('hello, world'); }");
v8::Script::Compile(context, v8src).ToLocal(&compiled_script);

//执行整个代码
v8::Local<v8::Value> result;
compiled_script->Run(context).ToLocal(&result);

//调用 hello 接口
v8::Local<v8::String> process_name = v8::String::NewFromUtf8(
    isolate, "hello", v8::NewStringType::kNormal, strlen("hello")).ToLocalChecked();
v8::Local<v8::Value> process_val;
v8::Local<v8::Function> process = v8::Local<v8::Function>::Cast(process_val);
context->Global()->Get(context, process_name).ToLocal(&process_val);
v8::Local<v8::Value> callresult;
process->Call(context, context->Global(), 0, nullptr).ToLocal(&callresult)

```
  执行结果：
```
hello, world
ledgerNum: 333333
```
### 虚拟机优化和保护措施
为了防止死循环，恶意内存泄露，恶意递归调用等各种问题，我们针对 V8 虚拟机，做了如下优化和保护。
  - 在 V8 内部解析 JS 代码的 AST 语法数，并根据语法数注入内置函数 `InternalCheckTime` 函数，每执行一步 JS 语句记 1 步，如果合约里调用内置函数则记 100 步，并规定如果计步超过 10 * 1024 后，该合约抛出异常不再执行
  - 如果 V8 执行 JS 代码超过 1 秒钟，该合约抛出异常不再执行
  - 如果 V8 的执行过程中，堆的内存使用超过 30 Mb，该合约抛出异常不再执行
  - 如果 V8 的执行过程中，栈的内存使用超过 512 Kb，该合约抛出异常不再执行

`TransactionFrm` 内实现了 `IsExpire` 接口，在执行合约回调 `InternalCheckTime` 函数时，进行计算和检测状态，如果满足以上条件则抛出 JS 执行异常且终止


## 智能合约语法规则介绍
  智能合约是一段 `JavaScript` 代码, 标准(ECMAScript as specified in ECMA-262)，并使用 JSLint 模块自定义了语法子集，目的是为了让合约的编写避免 js 语言中潜在的 bug 和 不良代码，让合约更具安全性和健壮性。
  例如：

  禁用关键字：
```
  "DataView", "decodeURI", "decodeURIComponent", "encodeURI", 
  "encodeURIComponent", "Generator","GeneratorFunction", "Intl", 
  "Promise", "Proxy", "Reflect", "System", "URIError", "WeakMap", 
  "WeakSet", "Math", "Date"
```

  - 所有的源码在开始必须要添加 "use strict"; 字段
  - 语句块内尽量使用 'let' 声明变量
  - 使用'===' 代替 '==' 判断比较；使用 '!==' 代替 '!=' 比较
  - 语句必须以 ';' 结束
  - 语句块必须用 '{}' 包括起来，且禁止空语句块
  - 'for' 的循环变量初始变量需在条件语句块之前声明，每次使用重新赋值
  - 禁用 '++' 和 '--'，使用 '+=' 和 '-=' 替代
  - 禁止使用 'eval', 'void', 'this' 关键字
  - 禁止使用 'new' 创建 'Number', 'String', 'Boolean'对象，可以使用其构造调用来获取对象
  - 禁止使用的数组关键字创建数组
  - 禁止使用 'try', 'catch' 关键字，可以使用 'throw' 手动抛出异常
  - 每次在创建智能合约的时候，会通过接口 ContractManager::SourceCodeCheck 调用 JSLint 的代码检测输入的内容是否合法，如果不合法会执行错误，并抛出异常信息

## 智能合约基本模板

必须包含三个接口：
  - init： 初始化函数，可以在函数内部调用读写数据的操作，只在智能合约账号被创建时候调用一次。
  - main： 执行的入口函数，可以在函数内部调用读写数据的操作，当向该智能合约发起一笔交易的时候，会触发执行该接口。
  - query：查询函数，可以在函数内部调用读的操作，用于被外部查询合约信息使用。

简化的模板如下：
```
"use strict";
function init(bar)
{
  /*init whatever you want*/
  return;
}

function main(input)
{
  let para = JSON.parse(input);
  if (para.do_foo)
  {
    let x = {
      'hello' : 'world'
    };
  }
}

function query(input)
{ 
  return input;
}
```

## 调试合约
  在智能合约模块的设计中，我们提供了沙箱环境来进行调试合约，且调试过程中不会更改区块链和合约的状态。
  在 BUMO 链上，我们为用户提供了 callContract 接口来帮助用户来调试智能合约，智能合约可以是公链上已存的，也可以是通过参数上传的合约代码进行测试，
  使用 callContract 接口不会发送交易，也就无需支付上链手续费。
```
  POST /callContract
```

  post 内容如下
```
  {
    "contract_address" : "",
    "code" : "\"use strict\";log(undefined);function query() { return 1; }",
    "input" : "{}",
    "contract_balance" : "100009000000",
    "fee_limit" : 100000000000000000,
    "gas_price": 1000,
    "opt_type" : 2,
    "source_address" : ""
  }
```

  - contract_address: 调用的智能合约地址，如果填空，则读取 code 字段的内容；如果填写了地址但从 bumo 链上查询不到则返回错误。
  - code：需要调试的合约代码，contract_address 和 code 优先使用 contract_address 字段查询，其次使用 code 值，如果都为空，则报错 。
  - input： 给被调用的合约传参。
  - fee_limit : 手续费。
  - gas_price : Gas价格。
  - contract_balance : 赋予合约的初始 BU 余额。
  - opt_type: 0: 调用合约的读写接口 init, 1: 调用合约的读写接口 main, 2 :调用只读接口 query。
  - source_address：模拟调用合约的原地址。

## 创建合约
合约是创建账号时确定的，即[创建账号](#创建账号)操作中，就确定了被创建的账号的合约内容。合约创建之后，不允许修改合约代码。

## 执行合约
### 触发机制
当一个合约账号收到其他账号转移的资产以后，就会被触发。

### 执行入口函数
 规定`function main(inputStr)`定义为合约执行的入口函数，其中，`inputStr`由触发者决定，即在[转移资产](#转移资产)接口中的`input`字段。`inputStr`是一个字符串。

### 查询函数 
`function query(inputStr)`是查询合约的函数，功能是根据入参，返回指定结果。此过程是不经过共识的，由节点自定义是否去实现。
例合约代码中有这样一段
```
function query(inputStr)
{
    var obj = JSON.parse(inputStr);
    return obj.x + obj.y;
}
```

## 内置实现接口和变量
 内部实现接口是指在编写智能合约的时候，能够在 js 代码里调用 Bumo 内部提供的读写区块链数据的接口和内置变量。
 这是通过 Google V8 引擎提供的 ObjectTemplate 实现 c++ 函数和 js 函数的绑定。参考 智能合约虚拟机介绍 章节

即可在js里直接使用该函数和变量
例如
```
let balance = getBalance("buQsZNDpqHJZ4g5hz47CqVMk5154w1bHKsHY");
let block_num = blockNumber;
```

## 内置函数
- ### 函数读写权限
    每个函数都有固定的**只读**或者**可写**权限

    只读权限是指**不会写数据到区块链**的接口函数，比如获取余额 `getBalance`

    可写权限是指**会写数据到区块链**的接口函数，比如转账 `payCoin`

    在编写智能合约的时候，需要注意的是不同的入口函数拥有不同的调用权限

    `init` 和 `main` 能调用所有的内置函数

    `query`  只能调用只读权限的函数，否则在调试或者执行过程中会提示接口未定义
  

- ### 返回值介绍
   所有内部函数的调用，如果失败则返回 false 或者直接抛出异常执行终止，成功则为其他对象。

- ### 获取账号信息(不包含metada和资产)

    `getBalance(address);`
    - address: 账号地址

    例如
    ```javascript
    let balance = getBalance('buQsZNDpqHJZ4g5hz47CqVMk5154w1bHKsHY');
    /*
      权限：只读
      返回：字符串格式数字 '9999111100000'
    */
    ```

- ### 存储合约账号的metadata信息
  `storageStore(metadata_key, metadata_value);`
  - metadata_key: metadata 的 key
  - metadata_key: metadata 的 value

  ```javascript
  storageStore('abc', 'values');
  /*
    权限：可写
    返回：成功返回true, 失败抛异常
  */

  ```

- ### 获取合约账号的metadata信息
  `storageLoad(metadata_key);`
  - metadata_key: metadata的key
  ```javascript
  let value = storageLoad('abc');
  /*
    权限：只读
    返回：成功返回字符串，如 'values', 失败返回false
  */

  ```
    即可得到本合约账号中自定数据的abc的值

- ### 删除合约账号的metadata信息
  `storageDel(metadata_key);`
  - metadata_key: metadata的key
  ```javascript
  storageDel('abc');
  /*
    权限：可写
    返回：成功返回true, 失败抛异常
  */

  ```
    即可删除本合约账号中自定数据的abc的值

- ### 获取某个账号的资产信息

    `getAccountAsset(account_address, asset_key);`

    - account_address: 账号地址
    - asset_key: 资产属性

    例如
    ```javascript
    let asset_key =
    {
      'issuer' : 'buQsZNDpqHJZ4g5hz47CqVMk5154w1bHKsHY',
      'code' : 'CNY'
    };
    let bar = getAccountAsset('buQsZNDpqHJZ4g5hz47CqVMk5154w1bHKsHY', asset_key);

    /*
      权限：只读
      返回：成功返回资产数字如'10000'，失败返回 false
    */
    ```

- ### 获取区块信息

    `getBlockHash(offset_seq);`
    - offset_seq: 距离最后一个区块的偏移量，最大1024

    例如
    ```javascript
    let ledger = getBlockHash(4);
    /*
      权限：只读
      返回：成功返回字符串，如 'c2f6892eb934d56076a49f8b01aeb3f635df3d51aaed04ca521da3494451afb3'，失败返回 false
    */

    ```

- ### 地址合法性检查

    `addressCheck(address);`
    - address 地址参数，字符串

    例如
    ```javascript
    let ret = addressCheck('buQgmhhxLwhdUvcWijzxumUHaNqZtJpWvNsf');
    /*
      权限：只读
      返回：成功返回 true，失败返回 false
    */

    ```

- ### 字符串数字合法性检查

    `stoI64Check(strNumber);`
    - strNumber：字符串数字参数

    例如
    ```javascript
    let ret = stoI64Check('12345678912345');
    /*
      权限：只读
      返回：成功返回 true，失败返回 false
    */

    ```

- ### 64位加法

    `int64Add(left_value, right_value);`
    - left_value: 左值
    - right_value：右值

    例如
    ```javascript
    let ret = int64Add('12345678912345', 1);
    /*
      权限：只读
      返回：成功返回字符串 '12345678912346', 失败抛异常
    */

    ```

- ### 64位减法

    `int64Sub(left_value, right_value);`
    - left_value: 左值
    - right_value：右值

    例如
    ```javascript
    let ret = int64Sub('12345678912345', 1);
    /*
      权限：只读
      返回：成功返回字符串 '123456789123464'，失败抛异常
    */

    ```
    
- ### 64位乘法

    `int64Mul(left_value, right_value);`
    - left_value: 左值
    - right_value：右值

    例如
    ```javascript
    let ret = int64Mul('12345678912345', 2);
    /*
      权限：只读
      返回：成功返回字符串 '24691357824690'，失败抛异常
    */

    ```

 - ### 64位除法

    `int64Div(left_value, right_value);`
    - left_value: 左值
    - right_value：右值

    例如
    ```javascript
    let ret = int64Div('12345678912345', 2);
    /*
      权限：只读
      返回：成功返回 '6172839456172'，失败抛异常
    */

    ```

 - ### 64位取模

    `int64Mod(left_value, right_value);`
    - left_value: 左值
    - right_value：右值

    例如
    ```javascript
    let ret = int64Mod('12345678912345', 2);
    /*
      权限：只读
      返回：成功返回字符串 '1'，失败抛异常
    */

    ```

 - ### 64位比较
    `int64Compare(left_value, right_value);`

    - 返回值 1：左值大于右值，0：等于，-1 ：小于
    - left_value: 左值
    - right_value：右值

    例如
    ```javascript
    let ret = int64Compare('12345678912345', 2);
    /*
      权限：只读
      返回：成功返回数字 1（左值大于右值），失败抛异常
    */

    ```
      
 - ### 变换单位
    `toBaseUnit(value);`

    - 返回值: 成功会返回乘以 10^8 的字符串，失败会返回 false
    - value: 被转换的数字，只能传入字符串，可以包含小数点，且小数点之后最多保留 8 位数字

    例如
    ```javascript
    let ret = toBaseUnit('12345678912');
    /*
      权限：只读
      返回：成功返回字符串 '1234567891200000000'，失败抛异常
    */

    ```

- ### 输出日志

    `log(info);`
     info: 日志内容

    例如
    ```javascript
    let ret = log('buQsZNDpqHJZ4g5hz47CqVMk5154w1bHKsHY');
    /*
      权限：只读
      返回：成功无返回值，失败返回 false
    */
    ```
- ### 输出交易日志

    `tlog(topic,args...);`
     - tlog会产生一笔交易写在区块上
     - topic: 日志主题，必须为字符串类型,参数长度(0,128]
     - args...: 最多可以包含5个参数，参数类型可以是字符串、数值或者布尔类型,每个参数长度(0,1024]

    例如
    ```javascript
    tlog('transfer',sender +' transfer 1000',true);
    /*
      权限：可写
      返回：成功返回 true，失败抛异常
    */
    ```

- ### 发行资产

    `issueAsset(code, amount);`
     - code: 资产代码
     - amount: 发行资产数量

    例如
    ```javascript
    issueAsset("CNY", "10000");
    /*
      权限：可写
      返回：成功返回 true，失败抛异常  
    */
    ```

- ### 转移资产

    `payAsset(address, issuer, code, amount[, input]);`
     - address: 转移资产的目标地址
     - issuer: 资产发行方
     - code: 资产代码
     - amount: 转移资产的数量
     - input: 可选，合约参数，如果用户未填入，默认为空字符串

    例如
    ```javascript
    payAsset("buQsZNDpqHJZ4g5hz47CqVMk5154w1bHKsHY", "buQgmhhxLwhdUvcWijzxumUHaNqZtJpWvNsf", "CNY", "10000", "{}");
    /*
      权限：可写
      返回：成功返回 true，失败抛异常    
    */
    ```

- ### 转账

    `payCoin(address, amount[, input]);`
     - address: 发送BU的目标地址
     - amount: 发送BU的数量
     - input: 可选，合约参数，如果用户未填入，默认为空字符串

    例如
    ```javascript
    payCoin("buQsZNDpqHJZ4g5hz47CqVMk5154w1bHKsHY", "10000", "{}");
    /*
      权限：可写
      返回：成功返回 true，失败抛异常  
    */
    ```

- ### 断言

    `assert(condition[, message]);`
     - condition: 断言变量
     - message: 可选，失败时抛出异常的消息

    例如
    ```javascript
    assert(1===1, "Not valid");
    /*
      权限：只读
      返回：成功返回 true，失败抛异常  
    */
    ```

## 内置变量

- ###  该合约账号的地址
   thisAddress

    全局变量`thisAddress`的值等于该合约账号的地址。

    例如账号x发起了一笔交易调用合约Y，本次执行过程中，thisAddress的值就是Y合约账号的地址。

    ```text
    let bar = thisAddress;
    /*
    bar的值是Y合约的账号地址。
    */
    ```

- ### 本次支付操作的 BU coin
    thisPayCoinAmount

- ### 本次支付操作的Asset
    thisPayAsset

    为对象类型{"amount": 1000, "key" : {"issuer": "buQsZNDpqHJZ4g5hz47CqVMk5154w1bHKsHY", "code":"CNY"}}
 
- ### 当前区块高度
    blockNumber
 
- ### 当前区块时间戳
    blockTimestamp

- ### 调用者的地址
    sender
    ```sender``` 的值等于本次调用该合约的账号。

    例如某账号发起了一笔交易，该交易中有个操作是调用合约Y（该操作的source_address是x），那么合约Y执行过程中，sender的值就是x账号的地址。

    ```javascript
    let bar = sender;
    /*
    那么bar的值是x的账号地址。
    */
    ```

- ### 触发本次合约调用的操作的序号
    triggerIndex

    ```triggerIndex``` 的值等于触发本次合约的操作的序号。

    例如某账号A发起了一笔交易tx0，tx0中第0（从0开始计数）个操作是给某个合约账户转移资产(调用合约), 那么```triggerIndex```的值就是0。

    ```javascript
    let bar = triggerIndex;
    /* bar 是一个非负整数*/
    ```

## 异常处理

- JavaScript异常

  当合约运行中出现未捕获的JavaScript异常时，处理规定：

  1. 本次合约执行失败，合约中做的所有交易都不会生效。
  1. 触发本次合约的这笔交易为失败。错误代码为`151`。

- 执行交易失败
  <font color=red>合约中可以执行多个交易，只要有一个交易失败，就会抛出异常，导致整个交易失败</font>

# 附录

## Merkel根
Merkel根是对一个(K,V)结构的集合的运算。其中K,V都是字节串。它的特性是：
- 根hash的结果只与树中数据的集合有关，与插入顺序无关。我们利用这个特性可以快速判断两个数据集合是否相同。
- 对于数据集合中的每一条(K,V)来说，K决定了一条数据在树中的位置，V决定了hash。(K,V)数据集合共同决定了根hash。
- 当修改、添加、或删除树中的数据时，只需要重算变化节点所在的路径即可。
- 修改任何一条数据必然引起根hash的变化，这是默克尔树的基本特征。

原理图：
![](images/MerkelTrieTree.png)

我们用16叉的字典树构造树结构。树中每个节点是一个Node。每一个Node的hash值是它本身散列之后得到的。

```
message Node
{
    repeated Child children = 1;
}

message Child
{
    bytes sublocation = 1;
    bytes hash = 2;
    CHILDTYPE childtype = 3;
}

enum CHILDTYPE
{
    NONE = 0;
    INNER = 1;
    LEAF = 2;
}
```
初始状态下，设定一个根Node。
其children有17个元素，初始化为默认值，即sublocation为空，hash为空，childtype为None。每个节点都有其索引，代表了该节点在树中的位置。children[0]~children[15]对应16个子节点，children[16]对应自身索引对应的数据。

添加/修改一个(K,V)的步骤
1. 将K用16进制表示，记为index。当前Node为根Node。
1. 取得当前Node，当前Node的索引记为index1
1. 如果index等于index1，取当前Node的第17号children记为chd。如果chd的childtype等于NONE或LEAF，设置
    ```
    chd.childtype = LEAF;
    chd.sublocation = index
    chd.hash = HASH(V)
    ```
    更新遍历过的所有Node的hash值。
1. 如果index不等于index1，找到它们的公共前缀，index去掉这个公共前缀之后下一个字符C（显然C值的范围是[0, 15]）。取Node的children第C个对象记为chd。
    - 若chd的type为NONE，设置
    ```
    chd.childtype = LEAF;
    chd.sublocation = index
    chd.hash = HASH(V)
    ```
    - 若chd的type为LEAF或INNER，取chd.sublocation与index的公共前缀记为prefix，若prefix等于chd.sublocation，进入步骤2。否则，若prefix等于index，则新建节点NodeNew其索引为index，chd.sublocation减去prefix后第一个字符为X,显然`0 < X < 16`。设置NodeNew的值
    ```
    NodeNew.children[16].childtype = LEAF;
    NodeNew.children[16].sublocation = index;
    NodeNew.children[16].hash = HASH(V);
    NodeNew.children[X] = chd;
    ```

```mermaid
graph TD;
    root("root");
```
添加一条数据，(K=0x35,V="hello")
```mermaid
graph TD;
    root("root");
    35("{35,hello}")
    root-->|3|35
```
添加一条数据，(K=0x35678,V="world")

```mermaid
graph TD;
    root("root");
    35("35,hello")
    root-->|3|35;
    35678("35678,world")
    35-->|6|35678;
```
添加一条数据，(K=0x35123,V="foo")

```mermaid
graph TD;
    root("root");
    35("35,hello")
    root-->|3|35;
    35123("35123,foo")
    35-->|1|35123
    35678("35678,world")
    35-->|6|35678;

```
添加一条数据，(K=0x34876,V="bar")

```mermaid
graph TD;
    root("root");
    3("3");
    34876(34876,bar);
    35("35,hello");
    35123("35123,foo");
    35678("35678,world");

    root-->3 
    3-->|4|34876
    3-->|5|35
    35-->|1|35123
    35-->|6|35678;
```

## protocol buffer与json的互相转换
在合约中我们用json格式，序列化时我们用protocol buffer格式。我们定义一种json与protocol buffer互相转换的规则

|proto3| JSON| json示例| 说明|
|--|--|--|--|
|message|object|{"bar":"foo"}||
|ENUM| int或string | 2, "CODE_SUCCESS" | |
|repeated V|array|[{...},{...},...]| |
|bool| true,false | true,false| |
|string|string|"hello world"|  |
|bytes| hex string| "0123456789abcdef" | bytes在proto3中是任意字节，转换成json格式后以16进制字符串表示。| |
|int32, fixed32, uint32|number|1, -10, 0||
|float, double|number|1, -10, 0||
|int64, fixed64, uint64|string|"1", "-10"||

